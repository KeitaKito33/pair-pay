■@Transactionalアノテーションについて
「このメソッド内のデータベース操作は、全部成功するか、全部失敗するかのどっちかにしてね！」という、非常に重要なお守りのようなものです。

あなたがAさんの口座からBさんの口座へ1万円を振り込む時、銀行のシステム内部では、主に2つの処理が行われます。
・Aさんの口座から1万円を引く。
・Bさんの口座に1万円を足す。

もし@Transactionalがなかったら…
もし、処理1（Aさんから引く）が成功した直後に、停電やシステムエラーが発生したらどうなるでしょうか？

Aさんの口座からは1万円が引かれたまま。
しかし、Bさんの口座には1万円が足されていない。

結果、宙に浮いた1万円が生まれてしまい、データベースの整合性が完全に壊れてしまいます。これは絶対に起きてはならない事態です。

@Transactionalがあると…
@Transactionalを振込処理全体に付けておくと、Spring（スプリング）がこの2つの処理を**「一つの塊（トランザクション）」**として扱ってくれます。

全部成功した場合: 処理1と処理2が両方とも無事に完了した場合にのみ、Springは「これで確定！」とデータベースに最終的な変更を保存（コミット）します。
途中で失敗した場合: もし処理1の後にエラーが起きたら、Springは**「今の全部なかったことにして！」と、処理1の変更（Aさんから1万円引いたこと）を自動的に取り消して、処理が始まる前の状態に完全に戻してくれます。これをロールバック**と呼びます。